#
# lara
#

indent_with_tabs				= 0			# 1=indent to level	only, 2=indent with	tabs
input_tab_size					= 4			# original tab size
output_tab_size					= 4			# new tab size
indent_columns					= 4			# The number of	columns	to indent per level
indent_label					= -4		# pos: absolute	col, neg: relative column
indent_align_string				= true		# align	broken strings
indent_func_call_param			= false		# use indent tabstop
indent_namespace				= true		# Whether the 'namespace' body is indented
indent_class					= true		# Whether the 'class' body is indented

nl_enum_brace					= add		# "enum	{" vs "enum	\n {"
nl_union_brace					= add		# "union {"	vs "union \n {"
nl_struct_brace					= add		# "struct {" vs	"struct	\n {"
nl_do_brace						= add		# "do {" vs	"do	\n {"
nl_if_brace						= add		# "if () {"	vs "if () \n {"
nl_for_brace					= add		# "for () {" vs	"for ()	\n {"
nl_else_brace					= add		# "else	{" vs "else	\n {"
nl_while_brace					= add		# "while ()	{" vs "while ()	\n {"
nl_switch_brace					= add		# "switch () {"	vs "switch () \n {"
nl_func_var_def_blk				= 1			# The number of	blank lines	after a	block of variable definitions at the top of	a function body
nl_fcall_brace					= add		# "foo() {"	vs "foo()\n{"
nl_fdef_brace					= add		# "int foo() {"	vs "int	foo()\n{"
nl_brace_else					= add		# Add or remove	newline	between	'}'	and	'else'
nl_after_return					= false		# Whether to put a blank line after	'return' statements, unless	followed by	a close	brace
#nl_before_return				= true		# Whether to put a blank line before 'return' statements, unless after an open brace
nl_before_case					= false		# Whether to put a newline before 'case' statement
nl_after_case					= true		# Whether to put a newline after 'case'	statement

indent_switch_case				= indent_columns	# Spaces to	indent 'case' from 'switch'. Usually 0 or indent_columns
indent_case_brace				= 0


nl_before_if					= force		# nl before	block
nl_after_if						= force		# nl after block
nl_before_for					= force		# nl before	block
nl_after_for					= force		# nl after block
nl_before_while					= force		# nl before	block
nl_after_while					= force		# nl after block
nl_before_switch				= force		# nl before	block
nl_after_switch					= force		# nl after block
nl_before_do					= force		# nl before	block
nl_after_do						= force		# nl after block

mod_full_brace_if				= add		# "if (a) a--;"	vs "if (a) { a--; }"
mod_full_brace_for				= add		# "for () a--;"	vs "for	() { a--; }"
mod_full_brace_do				= add		# "do a--; while ();" vs "do { a--;	} while	();"
mod_full_brace_while			= add		# "while (a) a--;" vs "while (a) { a--;	}"

sp_paren_paren					= force		# space	between	(( and ))
sp_return_paren					= ignore	# "return (1);"	vs "return(1);"
sp_sizeof_paren					= remove	# "sizeof (int)" vs	"sizeof(int)"
sp_before_sparen				= remove	# "if (" vs	"if("
sp_after_sparen					= remove	# "if () {"	vs "if (){"
sp_after_cast					= remove	# "(int) a"	vs "(int)a"
sp_inside_braces				= force		# "{ 1 }" vs "{1}"
sp_inside_braces_struct			= force		# "{ 1 }" vs "{1}"
sp_inside_braces_enum			= force		# "{ 1 }" vs "{1}"
sp_type_func					= ignore	# Add or remove	space between return type and function name. A minimum of 1	is forced except for pointer return	types
sp_assign						= force		# Add or remove	space around assignment	operator '=', '+=',	etc
sp_arith						= force		# Add or remove	space around arithmetic	operator '+', '-', '/',	'*', etc
sp_bool							= force		# Add or remove	space around boolean operators '&&'	and	'||'
sp_compare						= force		# Add or remove	space around compare operator '<', '>',	'==', etc
sp_inside_paren					= force		# Add or remove	space inside '(' and ')'
sp_inside_fparen				= force		# Add or remove	space inside function '(' and ')'
sp_inside_fparens				= remove	# Add or remove	space inside empty function	'()'
sp_inside_sparen				= force		# Add or remove	space inside '{' and '}'
sp_after_comma					= force		# Add or remove	space after	','
sp_before_comma					= remove	# Add or remove	space before ','
sp_func_def_paren				= remove	# "int foo (){"	vs "int	foo(){"
sp_func_call_paren				= remove	# "foo (" vs "foo("
sp_func_proto_paren				= remove	# "int foo ();"	vs "int	foo();"
sp_before_ptr_star				= remove	# Add or remove	space before pointer star '*'
sp_after_ptr_star				= force		# Add or remove	space after	pointer	star '*'
sp_before_byref					= remove	# Add or remove	space before a reference sign '&'
sp_after_byref					= force		# Add or remove	space after	reference sign '&',	if followed	by a word
sp_cond_colon					= add		# Add or remove	space around the ':' in	'b	? t	: f'
sp_cond_question_before			= remove	# Add or remove	space before the '?' in	'b ? t : f'. Overrides sp_cond_question


align_typedef_star_style		= 1
align_var_def_star_style		= 0			# How to align the star	in variable	definitions
align_keep_tabs                 = false
align_with_tabs                 = false
align_on_tabstop                = false
align_enum_equ_span				= 4
align_nl_cont					= true
align_var_def_span				= 1
align_var_def_inline			= true
align_var_def_colon				= true
align_assign_span				= 1
align_struct_init_span			= 3
align_var_struct_span			= 3
align_right_cmt_span			= 3
align_pp_define_span			= 3
align_pp_define_gap				= 4
align_typedef_span				= 5
align_typedef_gap				= 3

eat_blanks_before_close_brace	= true
eat_blanks_after_open_brace		= true

nl_using_brace					= add		# ignore/add/remove/force Add or remove	newline	between	'using'	and	'{'
nl_max							= 4			# The maximum consecutive newlines (3 = 2 blank lines)

nl_after_func_body_class		= 5			# The number of newlines after '}' of a multi-line function body in a class declaration
nl_after_func_body_one_liner	= 5			# The number of newlines after '}' of a single line function body

sp_getset_brace					= force		# ignore/add/remove/force Add or remove space between get/set and '{' if on the same line
nl_getset_leave_one_liners		= true		# false/true Don't split one-line get or set functions
nl_getset_brace					= add		# ignore/add/remove/force Add or remove newline between get/set and '{'
nl_property_brace				= add		# ignore/add/remove/force Add or remove newline between C# property and the '{'
